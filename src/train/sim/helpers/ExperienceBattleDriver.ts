import { choiceIds } from "../../../battle/agent/Choice";
import { BattleDriver, ChoiceSender } from
    "../../../battle/driver/BattleDriver";
import { Logger } from "../../../Logger";
import { Experience, ExperienceAgent, ExperienceAgentData } from "./Experience";
import { RewardStateDriver } from "./RewardStateDriver";

/** Base class for battle trackers that emit Experience objects. */
export abstract class ExperienceBattleDriver extends BattleDriver
{
    /** @override */
    protected readonly stateDriver =
        new RewardStateDriver(this.logger.addPrefix("StateDriver: "));

    /** Partial Experience data generated by the ExperienceAgent. */
    private expAgentData: ExperienceAgentData | null = null;

    constructor(agent: ExperienceAgent, sender: ChoiceSender, logger: Logger)
    {
        super(
            async (state, choices, agentLogger) =>
                this.expAgentData = await agent(state, choices, agentLogger),
            sender, logger);
    }

    /**
     * Hook for logging Experience objects.
     * @virtual
     */
    protected abstract async emitExperience(exp: Experience): Promise<void>;

    /** @override */
    public async halt(command: "wait" | "switch" | "decide"): Promise<void>
    {
        // still have to see the rest of the state transition
        if (command === "wait") return super.halt(command);

        const reward = this.stateDriver.consumeReward();

        // after observing a state transition, emit an Experience
        if (this.expAgentData)
        {
            const data = this.expAgentData;
            this.expAgentData = null;
            // choices array hasn't been updated since the last halt() so we can
            //  use this field to get the action that caused the state
            //  transition we just finished handling
            const lastAction = choiceIds[this.choices[0]];
            await this.emitExperience({...data, action: lastAction, reward});
        }

        return super.halt(command);
    }
}
