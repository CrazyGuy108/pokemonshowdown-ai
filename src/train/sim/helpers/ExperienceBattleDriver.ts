import { choiceIds } from "../../../battle/agent/Choice";
import { BattleDriver, ChoiceSender, CommandType } from
    "../../../battle/driver/BattleDriver";
import { Any } from "../../../battle/driver/BattleEvent";
import { Logger } from "../../../Logger";
import { Experience, ExperienceAgent, ExperienceAgentData } from "./Experience";

/** Base class for battle trackers that emit Experience objects. */
export abstract class ExperienceBattleDriver extends BattleDriver
{
    /** Keeps track of current reward. */
    private reward = 0;

    /** Partial Experience data generated by the ExperienceAgent. */
    private expAgentData: ExperienceAgentData | null = null;

    constructor(agent: ExperienceAgent, sender: ChoiceSender, logger: Logger)
    {
        super(
            async (state, choices, agentLogger) =>
                this.expAgentData = await agent(state, choices, agentLogger),
            sender, logger);
    }

    /**
     * Hook for logging Experience objects.
     * @abstract
     */
    protected abstract async emitExperience(exp: Experience): Promise<void>;

    /** @override */
    public handle(...events: Any[]): void
    {
        // apply win/loss reward if needed
        const lastEvent = events[events.length - 1];
        if (lastEvent.type === "gameOver")
        {
            // count ties as losses
            this.reward = lastEvent.winner === "us" ? 1 : -1;
        }
        return super.handle(...events);
    }

    /** @override */
    public async halt(command: CommandType): Promise<void>
    {
        // still have to see the rest of the state transition
        if (command === "wait") return super.halt(command);

        const reward = this.reward;
        this.reward = 0;

        // after observing a state transition, emit an Experience
        if (this.expAgentData)
        {
            const data = this.expAgentData;
            this.expAgentData = null;
            // choices array hasn't been updated since the last halt() so we can
            //  use this field to get the action that caused the state
            //  transition we just finished handling
            const lastAction = choiceIds[this.choices[0]];
            await this.emitExperience({...data, action: lastAction, reward});
        }

        return super.halt(command);
    }
}
