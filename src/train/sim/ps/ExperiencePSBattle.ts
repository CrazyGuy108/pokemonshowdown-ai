import { choiceIds } from "../../../battle/agent/Choice";
import { Logger } from "../../../Logger";
import { BattleInitMessage, BattleProgressMessage } from
    "../../../psbot/parser/Message";
import { PSBattle } from "../../../psbot/PSBattle";
import { Sender } from "../../../psbot/PSBot";
import { PSEventHandler } from "../../../psbot/PSEventHandler";
import { Experience, ExperienceAgent, ExperienceAgentData } from
    "../helpers/Experience";
import { RewardBattleDriver } from "../helpers/RewardBattleDriver";

/**
 * PSBattle that emits Experience objects. Should be subclassed to define where
 * the emitted Experience objects should go.
 */
export abstract class ExperiencePSBattle extends PSBattle
{
    /** @override */
    protected readonly driver!: RewardBattleDriver;
    /** @override */
    protected readonly agent!: ExperienceAgent;
    /** Partial Experience data generated by the BattleAgent. */
    private expAgentData: ExperienceAgentData | null = null;

    constructor(username: string, agent: ExperienceAgent, sender: Sender,
        logger: Logger, driverCtor = RewardBattleDriver,
        eventHandlerCtor?: typeof PSEventHandler)
    {
        super(username, async (state, choices) =>
            {
                this.expAgentData = await agent(state, choices);
            }, sender, logger, driverCtor, eventHandlerCtor);
    }

    /**
     * Hook for logging Experience objects. This method owns the given
     * Experience, so it must be properly disposed once it's done being used.
     * @virtual
     */
    protected abstract async emitExperience(exp: Experience): Promise<void>;

    /** @override */
    public async init(msg: BattleInitMessage): Promise<void>
    {
        await super.init(msg);

        // the rewards from the init turn don't matter since it's not a result
        //  of our actions
        // TODO: team preview?
        this.driver.consumeReward();
    }

    /** @override */
    public async progress(msg: BattleProgressMessage): Promise<void>
    {
        // store the last prediction that was made, which will be handled by the
        //  environment
        if (this.shouldRespond() && this.expAgentData)
        {
            // consume current network data
            const expAgentData = this.expAgentData;
            this.expAgentData = null;
            const lastAction = choiceIds[this.lastChoices[0]];

            // observe the state transition and the reward gained from it
            await super.progress(msg);
            // previous state transitions that didn't emit an experience are
            //  also included here, since multiple transitions can occur if the
            //  opponent has to make more than one decision (fainting,
            //  self-switch moves, etc)
            const reward = this.driver.consumeReward();

            // compile everything into an Experience
            return this.emitExperience(
                {...expAgentData, action: lastAction, reward});
        }
        // just observe the state transition
        return super.progress(msg);
    }
}
